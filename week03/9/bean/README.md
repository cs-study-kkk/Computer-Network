# 컴퓨터 네트워크: 전송 계층과 네트워크 계층

---

## 1. 패킷 손실과 지연의 발생 원리

네트워크를 도로 시스템에 비유하면

- **도로 폭(n차선)** = 네트워크 대역폭
- **차량** = 데이터 패킷
- **신호등** = 라우터 처리 능력
- **교통 체증** = 패킷 큐잉

### 패킷 손실과 지연의 원인

#### 1.1 주요 조건
- **패킷이 라우터 버퍼에 큐잉됨** ← 차량이 신호등에서 대기
- **패킷 도착률이 출력 링크 용량을 초과함** ← 도로가 포화 상태
- **패킷이 큐잉되어 순서를 기다림** ← 차량들이 줄을 서서 대기

#### 1.2 라우터 버퍼의 동작 방식

- **전송 완료**: 이미 수신 확인된 패킷들 (ACK 받음)
- **전송 중**: 전송되었지만 아직 확인되지 않은 패킷들 (타임아웃 대기)
- **대기 중**: 아직 전송되지 않은 패킷들 (전송 대기)

#### 1.3 네트워크 흐름 예시

1. 컴퓨터 A와 C에서 동시에 데이터 전송
2. 라우터 버퍼에서 패킷들이 큐잉
3. 버퍼가 가득 차면 새로운 패킷은 손실됨

---

## 2. HTTP 프로토콜 개요

HTTP를 도서관 시스템에 비유하면
- **도서관** = 웹 서버
- **도서관 이용자** = 웹 클라이언트
- **도서 요청** = HTTP 요청
- **도서 대출** = HTTP 응답

### HTTP의 정의와 특징

#### 2.1 HTTP (Hypertext Transfer Protocol)
- **정의**: 웹의 애플리케이션 계층 프로토콜
- **역할**: 웹 브라우저와 웹 서버 간의 통신 규약

#### 2.2 클라이언트-서버 모델

**클라이언트 (Client)**
- HTTP 프로토콜을 사용하여 웹 객체를 요청하고, 수신하며, 표시하는 브라우저
- **예시**: Firefox 브라우저를 실행하는 PC, Safari 브라우저를 실행하는 iPhone

**서버 (Server)**
- 요청에 대한 응답으로 HTTP 프로토콜을 사용하여 객체를 전송하는 웹 서버
- **예시**: Apache 웹 서버를 실행하는 서버

#### 2.3 HTTP 통신 흐름
```
1단계: 도서 요청
클라이언트 → 서버: "웹페이지 주세요"

2단계: 도서 대출
서버 → 클라이언트: "여기 웹페이지입니다"

3단계: 다양한 이용자
- PC 사용자 (Firefox)
- 모바일 사용자 (Safari)
- 모두 같은 서버 이용
```

### HTTP 연결 방식

#### 2.4 비지속적 HTTP vs 지속적 HTTP

| 구분 | 비지속적 HTTP | 지속적 HTTP |
|------|---------------|-------------|
| **연결 방식** | 매번 새 연결 | 연결 재사용 |
| **효율성** | 낮음 | 높음 |
| **비유** | 매번 도서관 카드 발급 | 도서관 카드 재사용 |

**비지속적 HTTP의 문제점:**
- 연결 설정/해제 오버헤드가 큼
- 여러 객체 다운로드 시 여러 연결 필요

**지속적 HTTP의 장점:**
- 연결 오버헤드 감소
- 전송 효율성 향상

HTTP/1.1 부터 Connection: keep-alive 헤더를 이용하여 지속적 HTTP 구현, 현재는 HTTP/3 이 보편적

---

## 3. UDP와 TCP 비교

### UDP (User Datagram Protocol)

#### 3.1 UDP의 특징
- **신뢰성**: 없음 (데이터 손실 가능)
- **순서 보장**: 없음
- **연결**: 없음 (비연결형)
- **속도**: 빠름

#### 3.2 UDP의 주요 용도

**스트리밍 멀티미디어 애플리케이션**
- **Loss tolerant**: 일부 데이터 손실을 허용
- **Rate sensitive**: 일정한 데이터 전송률이 중요
- **예시**: 실시간 비디오 스트리밍, 온라인 게임

**기타 UDP 사용 사례**
- **DNS (Domain Name System)**: 도메인 이름을 IP 주소로 변환
- **SNMP (Simple Network Management Protocol)**: 네트워크 장치 관리

#### 3.3 UDP 세그먼트 형식

| 필드 | 크기 | 설명 |
|------|------|------|
| **Source Port #** | 16 bits | 송신자의 포트 번호 |
| **Dest Port #** | 16 bits | 수신자의 포트 번호 |
| **Length** | 16 bits | UDP 헤더와 데이터의 총 길이 |
| **Checksum** | 16 bits | 오류 검출을 위한 체크섬 |
| **Application Data** | 가변 | 실제 전송할 데이터 (메시지) |

### TCP (Transmission Control Protocol)

#### 3.4 TCP의 특징
- **신뢰성**: 있음 (데이터 손실 없음)
- **순서 보장**: 있음
- **연결**: 있음 (연결형)
- **속도**: 상대적으로 느림

#### 3.5 TCP의 주요 기능

**6가지 핵심 특징:**
1. **점대점 (Point-to-point)**: 하나의 송신자와 하나의 수신자
2. **신뢰할 수 있는 바이트 스트림**: 데이터 손실 없이 순서대로 전달
3. **파이프라인**: 여러 세그먼트를 동시에 전송
4. **전이중 데이터**: 양방향 동시 통신
5. **연결 지향**: 데이터 교환 전 연결 설정
6. **흐름 제어**: 수신자 처리 능력에 맞춰 전송 속도 조절

#### 3.6 TCP 세그먼트 구조

| 필드 | 크기 | 설명 |
|------|------|------|
| **Source Port #** | 16 bits | 송신자의 포트 번호 |
| **Dest Port #** | 16 bits | 수신자의 포트 번호 |
| **Sequence Number** | 32 bits | 데이터의 순서를 나타내는 시퀀스 번호 |
| **Acknowledgement Number** | 32 bits | 다음에 기대하는 데이터의 시퀀스 번호 |
| **Head Len** | 4 bits | TCP 헤더의 길이 (4바이트 단위) |
| **Not Used** | 6 bits | 사용하지 않는 예약된 필드 |
| **Flags (UAPRSF)** | 6 bits | 제어 플래그 (URG, ACK, PSH, RST, SYN, FIN) |
| **Receive Window** | 16 bits | 수신 버퍼의 가용 공간 크기 |
| **Checksum** | 16 bits | 오류 검출을 위한 체크섬 |
| **Urgent Data Pointer** | 16 bits | 긴급 데이터의 위치 (URG 플래그가 설정된 경우) |
| **Options** | 가변 | 추가 옵션들 (최대 세그먼트 크기 등) |
| **Application Data** | 가변 | 실제 전송할 데이터 |

### UDP vs TCP 비교표

| 특징 | UDP | TCP |
|------|-----|-----|
| **신뢰성** | 없음 | 있음 |
| **순서 보장** | 없음 | 있음 |
| **연결** | 비연결형 | 연결형 |
| **속도** | 빠름 | 상대적으로 느림 |
| **용도** | 실시간 스트리밍, DNS | 웹, 이메일, 파일 전송 |
| **비유** | 우편 (편지) | 전화 (통화) |

---

## 4. 신뢰할 수 있는 데이터 전송

### 신뢰성의 필요성

#### 4.1 비신뢰적 채널에서의 문제점

**패킷 오류 (Packet error)**
- 전송 중 데이터가 손상됨
- **예시**: 노이즈로 인한 비트 오류

**패킷 손실 (Packet loss)**
- 패킷이 네트워크에서 사라짐
- **예시**: 라우터 버퍼 오버플로우

### 문제 해결 메커니즘

#### 4.2 패킷 오류 처리
- **오류 감지 (Error detection)**: 데이터 손상 여부 확인
- **피드백 (Feedback)**: 수신자가 송신자에게 상태 전달
- **재전송 (Retransmission)**: 손상된 데이터 재전송
- **시퀀스 번호 (Sequence#)**: 패킷 순서 관리

#### 4.3 패킷 손실 처리
- **타임아웃 (Timeout)**: 일정 시간 내 응답이 없으면 재전송

### 책 읽기 비유

신뢰할 수 있는 데이터 전송을 책 읽기에 비유한다:

- **책의 페이지 번호** = 시퀀스 번호
- **다음에 읽을 페이지** = ACK 번호
- **책 읽기** = 바이트 스트림 처리
- **페이지 손실** = 패킷 손실
- **페이지 재요청** = 재전송

---

## 5. 파이프라인 프로토콜

### 공장 생산라인 비유

파이프라인 프로토콜을 공장 생산라인에 비유한다:

- **정지-대기**: 한 번에 하나씩 제품 생산
- **파이프라인**: 여러 제품을 동시에 생산

### 파이프라인의 필수 조건

#### 5.1 시퀀스 번호 범위 증가
- 동시에 전송되는 패킷이 많아지므로, 각 패킷을 고유하게 식별하기 위한 시퀀스 번호의 범위가 충분히 커야 한다.

#### 5.2 송신자 및/또는 수신자 버퍼링
- 전송 중인 패킷이나 수신되었지만 아직 애플리케이션 계층으로 전달되지 않은 패킷들을 임시로 저장하기 위한 버퍼 공간이 필요하다.

### 프로토콜 작동 방식 비교

#### (a) 정지-대기(Stop-and-Wait) 프로토콜
```
송신자: 패킷 전송 → ACK 대기 → 다음 패킷 전송
수신자: 패킷 수신 → ACK 전송
```
- **단점**: 네트워크 링크의 활용률이 낮음

#### (b) 파이프라인 프로토콜
```
송신자: 패킷1 전송 → 패킷2 전송 → 패킷3 전송 → ...
수신자: ACK1 전송 → ACK2 전송 → ACK3 전송 → ...
```
- **장점**: 네트워크 링크의 대역폭을 최대한 활용

### 파이프라인 프로토콜의 두 가지 형태

#### Go-Back-N
- **동작**: 손실된 패킷 이후 모든 패킷 재전송
- **수신자**: 순서대로 도착한 패킷만 수락
- **비유**: 책의 한 페이지가 빠지면 그 이후 모든 페이지를 다시 보내기

#### Selective Repeat
- **동작**: 손실된 특정 패킷만 선택적으로 재전송
- **수신자**: 순서에 상관없이 모든 유효한 패킷을 버퍼에 저장
- **비유**: 빠진 페이지만 다시 요청하기

| 특징 | Go-Back-N | Selective Repeat |
|------|-----------|------------------|
| **재전송 방식** | 손실된 패킷 이후 모든 패킷 재전송 | 손실된 패킷만 선택적 재전송 |
| **수신자 버퍼링** | 불필요 | 필요 |
| **복잡도** | 단순 | 복잡 |
| **효율성** | 낮음 | 높음 |

---

## 6. TCP의 핵심 메커니즘

### TCP 시퀀스 번호와 ACK

#### 6.1 시퀀스 번호와 ACK 정의

**시퀀스 번호 (Sequence Numbers)**
- **정의**: 세그먼트 데이터의 첫 번째 바이트에 대한 바이트 스트림 번호
- **특징**: 세그먼트 단위가 아닌 바이트 단위로 데이터를 계산

**확인 응답 (ACKs)**
- **정의**: 상대방으로부터 기대하는 다음 바이트의 시퀀스 번호
- **특징**: 누적 확인 응답 (cumulative ACK)

#### 6.2 텔넷 시나리오 상세 분석

```
단계 1: 사용자가 'C' 입력
Host A: "42번 페이지부터 'C' 내용을 보내겠습니다"
Host A: "79번 페이지를 기다리고 있습니다"

단계 2: Host B가 'C' 에코
Host B: "79번 페이지부터 'C' 내용을 보내겠습니다"
Host B: "43번 페이지를 기다리고 있습니다" (42번 수신 완료)

단계 3: Host A가 에코 확인
Host A: "43번 페이지부터 보내겠습니다"
Host A: "80번 페이지를 기다리고 있습니다" (79번 수신 완료)
```

### TCP 재전송 시나리오

#### 6.3 누적 ACK 시나리오

**초기 상태**
- SendBase: 120 (호스트 A가 아직 확인 응답을 받지 못한 데이터의 시작 시퀀스 번호)

**데이터 전송 과정**
1. **첫 번째 패킷**: "Seq=92, 8 bytes data" (성공적으로 수신됨)
2. **두 번째 패킷**: "Seq=100, 20 bytes data" (손실됨)

**패킷 손실 처리**
- **ACK=100**: 호스트 B가 99번까지의 데이터 수신 완료를 알림
- **타임아웃**: 호스트 A가 ACK를 받지 못하여 재전송 타이머 만료
- **재전송**: 손실된 "Seq=100, 20 bytes data" 패킷 재전송
- **ACK=120**: 호스트 B가 119번까지의 모든 데이터 수신 완료를 알림

### TCP Fast Retransmit

#### 6.4 타임아웃의 문제점
일반적인 타임아웃 기간은 상대적으로 길어서, 손실된 패킷을 재전송하기까지 긴 지연이 발생할 수 있다.

#### 6.5 Fast Retransmit의 작동 방식

**조건**
- 송신자가 동일한 데이터에 대해 3개의 중복 ACK를 수신하면, ACK된 데이터 이후의 세그먼트가 손실되었다고 가정

**동작**
- 송신자는 타임아웃 타이머가 만료되기 전에 해당 세그먼트를 즉시 재전송
- 이를 "고속 재전송(fast retransmit)"이라고 한다

**장점**
- 빠른 복구: 타임아웃을 기다리지 않고 즉시 재전송
- 효율성 향상: 네트워크 대역폭을 더 효율적으로 활용

### TCP 혼잡 제어: AIMD

#### 6.6 수도관 시스템 비유

TCP 혼잡 제어를 수도관 시스템에 비유하면

- **수도관**: 네트워크 링크
- **물의 양**: 데이터 양
- **수압**: 네트워크 혼잡도
- **밸브 조절**: 혼잡 제어

#### 6.7 AIMD (Additive Increase, Multiplicative Decrease)

**가산 증가 (Additive Increase)**
- 혼잡 윈도우 크기를 매 RTT마다 1 MSS씩 선형적으로 증가
- 네트워크에 부담을 주지 않으면서 사용 가능한 대역폭을 '탐색'

**곱셈 감소 (Multiplicative Decrease)**
- 패킷 손실이 감지되면, 혼잡 윈도우 크기를 즉시 절반으로 줄임
- 네트워크 혼잡이 발생했음을 인지하고 빠르게 전송률을 낮춤

#### 6.8 톱니파(Sawtooth) 동작

**온도 조절 비유**
- **가산 증가**: 온도를 천천히 올리기 (1도씩)
- **곱셈 감소**: 온도가 너무 높으면 절반으로 낮추기
- **톱니파**: 온도가 올라가다가 급격히 떨어지는 패턴

### TCP Tahoe vs TCP Reno

#### 6.9 자동차 운전 비유

- **TCP Tahoe**: 급브레이크 후 천천히 가속
- **TCP Reno**: 급브레이크 후 적당한 속도로 가속
- **결과**: Reno가 더 부드럽고 효율적인 운전

#### 6.10 TCP Tahoe 동작

1. **초기 Slow Start**: 혼잡 윈도우가 1에서 시작하여 지수적으로 증가
2. **Congestion Avoidance**: Threshold에 도달한 후 선형적으로 증가
3. **손실 감지**: 패킷 손실 시 혼잡 윈도우를 1로 재설정하고 Slow Start 재시작
4. **재시작**: 다시 1부터 지수적으로 증가

#### 6.11 TCP Reno 동작

1. **손실 감지**: 손실을 감지하면 혼잡 윈도우를 절반으로 줄임
2. **Fast Recovery**: Slow Start를 거치지 않고 바로 혼잡 회피 단계로 진입
3. **빠른 회복**: 더 빠르게 네트워크 대역폭을 활용

#### 6.12 성능 비교

| 특징 | TCP Tahoe | TCP Reno |
|------|-----------|----------|
| **손실 감지 시 혼잡 윈도우** | 1로 설정 | 절반으로 설정 |
| **회복 방식** | Slow Start 재시작 | Fast Recovery |
| **회복 속도** | 느림 | 빠름 |
| **네트워크 효율성** | 낮음 | 높음 |

---

## 7. 네트워크 계층 개요

### 네트워크 계층의 목표

#### 7.1 주요 목표
1. **네트워크 계층 서비스 모델 이해**
2. **포워딩(Forwarding) vs 라우팅(Routing) 구분**
3. **라우터의 동작 방식 이해**
4. **라우팅(경로 선택) 알고리즘 학습**
5. **브로드캐스트, 멀티캐스트 이해**
6. **인터넷에서의 구현과 인스턴스화**

### 네트워크 계층의 역할

#### 7.2 기본 기능
- **송신 호스트에서 수신 호스트로 전송 세그먼트 전달**
- **송신 측**: 세그먼트를 데이터그램으로 캡슐화
- **수신 측**: 전송 계층으로 세그먼트 전달
- **모든 호스트와 라우터에 네트워크 계층 프로토콜 존재**
- **라우터**: 통과하는 모든 IP 데이터그램의 헤더 필드 검사

#### 7.3 계층 구조에서의 위치
```
애플리케이션 계층
전송 계층 ← 네트워크 계층이 전송 세그먼트를 처리
네트워크 계층 ← 여기서 데이터그램으로 캡슐화
데이터 링크 계층
물리 계층
```

### 네트워크 계층의 두 가지 핵심 기능

#### 7.4 포워딩 (Forwarding)
- **정의**: 패킷을 라우터의 입력에서 적절한 라우터 출력으로 이동
- **비유**: 여행 중 특정 교차로를 통과하는 과정
- **특징**: 개별 라우터에서의 로컬 결정

#### 7.5 라우팅 (Routing)
- **정의**: 소스에서 목적지까지 패킷이 취하는 경로 결정
- **비유**: 출발지에서 목적지까지의 전체 여행 계획
- **특징**: 전체 네트워크 경로에 대한 전역적 결정

#### 7.6 포워딩 vs 라우팅 비교

| 구분 | 포워딩 (Forwarding) | 라우팅 (Routing) |
|------|-------------------|------------------|
| **범위** | 개별 라우터 | 전체 네트워크 |
| **시점** | 실시간 | 사전 계획 |
| **비유** | 교차로 통과 | 여행 계획 |
| **복잡도** | 단순 | 복잡 |

### 라우팅과 포워딩의 상호작용

#### 7.7 동작 과정
1. **라우팅 알고리즘**: 네트워크를 통한 엔드-투-엔드 경로 결정
2. **포워딩 테이블**: 이 라우터에서의 로컬 포워딩 결정
3. **실제 전송**: 도착하는 패킷의 헤더 값을 기반으로 출력 링크 결정

#### 7.8 예시
```
라우팅 알고리즘 → 포워딩 테이블 생성
헤더 값: 0111 → 출력 링크: 2번
헤더 값: 0100 → 출력 링크: 3번
```

---

## 8. 데이터그램 네트워크

### 우편 시스템 비유

데이터그램 네트워크를 우편 시스템에 비유한다:

- **전통적 전화**: 연결 설정 후 통화 (가상 회선)
- **우편 시스템**: 각 편지가 독립적으로 전송 (데이터그램)

### 데이터그램 네트워크의 특징

#### 8.1 기본 원리
- **네트워크 계층에서 호출 설정 없음**: 연결 설정 과정이 없음
- **라우터**: 엔드-투-엔드 연결에 대한 상태 정보 없음
- **네트워크 수준의 "연결" 개념 없음**: 연결 없는 패킷 전송
- **목적지 호스트 주소를 사용한 패킷 포워딩**

#### 8.2 우편 시스템의 특징
- 각 편지는 독립적으로 처리
- 경로가 다를 수 있음
- 순서가 바뀔 수 있음
- 연결 설정 없음

### 데이터그램 포워딩 테이블

#### 8.3 주소 범위 기반 포워딩
- **문제**: 40억 개의 IP 주소를 개별적으로 나열할 수 없음
- **해결책**: 주소 범위를 나열하여 테이블 항목 집계

#### 8.4 포워딩 테이블 구조
```
목적지 주소 범위    출력 링크
주소 범위 1        3
주소 범위 2        2
주소 범위 3        2
주소 범위 4        1
```

### 최장 접두사 매칭 (Longest Prefix Matching)

#### 8.5 원리
- **정의**: 주어진 목적지 주소에 대한 포워딩 테이블 항목을 찾을 때, 목적지 주소와 일치하는 가장 긴 주소 접두사를 사용
- **목적**: 가장 구체적인 경로를 선택

#### 8.6 우편 주소 시스템 비유
- **일반 주소**: "서울시" → 일반 우체국
- **구체적 주소**: "서울시 강남구" → 강남 우체국
- **가장 구체적 주소**: "서울시 강남구 테헤란로" → 해당 지역 우체국

#### 8.7 예시 테이블
```
목적지 주소 범위                    링크 인터페이스
11001000 00010111 00010*** *********    0
11001000 00010111 00011000 *********    1
11001000 00010111 00011*** *********    2
그 외의 경우                              3
```

#### 8.8 매칭 예시
1. **DA: 11001000 00010111 00010110 10100001**
   - 00010*** 패턴과 일치 → 인터페이스 0

2. **DA: 11001000 00010111 00011000 10101010**
   - 00011000 패턴과 일치 → 인터페이스 1 (더 구체적)

---

## 요약

### 핵심 개념 정리

1. **패킷 손실과 지연**: 도로 교통 체증과 같은 원리로 발생
2. **HTTP**: 도서관 시스템과 같은 클라이언트-서버 모델
3. **UDP vs TCP**: 우편 vs 전화의 차이
4. **신뢰할 수 있는 전송**: 책 읽기와 같은 순차적 처리
5. **파이프라인**: 공장 생산라인과 같은 효율적 처리
6. **TCP 메커니즘**: 복잡하지만 신뢰성 있는 통신
7. **네트워크 계층**: 전 세계를 연결하는 핵심 계층
8. **데이터그램**: 우편 시스템과 같은 독립적 패킷 전송

### 학습 목표 달성

- 네트워크 계층의 원리 이해
- 포워딩과 라우팅의 차이점 파악
- 라우터의 동작 방식 이해
- TCP와 UDP의 특징 비교
- 신뢰할 수 있는 데이터 전송 메커니즘 학습
- 네트워크 혼잡 제어 알고리즘 이해

---

