## 신뢰성 있는 데이터 전송(Principles of Reliable Data Transfer)

### 신뢰성 없는 채널에서 발생할 수 있는 문제
- **패킷 오류(Packet error)**: 데이터가 손상되어 도착
- **패킷 손실(Packet loss)**: 데이터가 아예 도착하지 않음

### 패킷 오류를 처리하는 메커니즘
- **오류 검출(Error detection)**: 데이터가 손상되었는지 확인 (예: 체크섬)
- **피드백(Feedback)**: 수신자가 송신자에게 정상 수신(ACK) 또는 오류(NAK)를 알림
- **재전송(Retransmission)**: 오류나 손실이 발생한 경우, 송신자가 데이터를 다시 전송
- **순서 번호(Sequence#)**: 패킷의 순서를 구분하여 중복/순서 오류 방지

### 패킷 손실을 처리하는 메커니즘
- **타임아웃(Timeout)**: 일정 시간 내에 응답이 없으면 송신자가 재전송

### 실제 프로토콜과의 관계
- 실제 프로토콜(TCP 등)은 더 복잡하지만, 위 원칙을 기반으로 동작함

---

## rdt3.0의 성능(Performance of rdt3.0)

- rdt3.0(Stop-and-Wait 방식)은 동작은 하지만 성능이 매우 낮음
- 예시: 1Gbps 링크, 15ms 왕복 지연, 1KB 패킷
  - 패킷 전송 시간(L/R): 8kb/1Gbps = 8마이크로초
  - 송신자 활용도(U): U = L/R / (RTT + L/R) ≈ 0.00027 (0.027%)
  - 1KB 패킷을 30ms마다 전송 → 초당 33kB 처리량 (1Gbps 링크에서 매우 비효율적)
- 네트워크 프로토콜이 물리적 자원 활용을 제한함

- 이유는?
  - 1. Stop-and-Wait 방식이란?
    송신자가 하나의 패킷을 전송한 후, **수신자의 확인 응답(ACK)**을 기다림
    ACK를 받기 전까지는 다음 패킷을 전송하지 않음
    즉, 동시에 하나의 패킷만 전송됨

    패킷을 하나 보내고 → 확인 응답 기다리고 → 그 다음 패킷 전송
    RTT(왕복 시간)가 길면 길수록, 이 기다리는 시간이 전체 시간에서 차지하는 비율이 커짐
    반면 전송 시간은 매우 짧아서, 링크의 전송 능력을 거의 활용하지 못함

---

## 파이프라이닝 프로토콜(Pipelined Protocols)

- **파이프라이닝(Pipelining)**: 송신자가 여러 개의 패킷을 동시에 전송(아직 ACK를 받지 않은 상태)
  - 순서 번호 범위 증가 필요
  - 송신자/수신자 버퍼링 필요
- **Stop-and-Wait**: 한 번에 하나의 패킷만 전송, ACK를 받아야 다음 전송 가능
- **파이프라인 방식**: 여러 패킷을 연속적으로 전송 가능
- 파이프라인 프로토콜의 두 가지 대표 형태:
  - **Go-Back-N**
  - **Selective Repeat**

### 파이프라이닝의 효과
- 활용도(Throughput) 대폭 증가
- 예시: 3개의 패킷을 파이프라이닝하면 활용도가 3배 증가
  - U = 3*L/R / (RTT + L/R) ≈ 0.0008 (Stop-and-Wait 대비 3배)

---

## Go-Back-N (GBN) 프로토콜

- **송신자(Sender):**
  - 패킷 헤더에 k-비트 순서 번호(k-bit seq #) 사용
  - 최대 N개의 연속적인 미확인(ACK되지 않은) 패킷을 윈도우(window) 내에서 전송 가능
  - 윈도우(window) 내 상태:
    - 이미 ACK 받은 구간
    - 전송했으나 아직 ACK를 받지 못한 구간
    - 아직 전송하지 않은 구간
    - 윈도우 밖(전송 불가)
  - 누적 ACK(cumulative ACK): n번까지의 모든 패킷을 한 번에 확인
  - 중복 ACK 수신 가능
  - 각 전송 중인 패킷마다 타이머를 둠
  - 타임아웃 발생 시, 해당 패킷 n 및 그 이후 윈도우 내 모든 패킷을 재전송

- **송신자 FSM(상태 기계) 요약:**
  - base, nextseqnum 관리
  - nextseqnum < base+N 이면 패킷 생성 및 전송, 타이머 시작, nextseqnum 증가
  - 윈도우가 가득 차면 데이터 거부(refuse)
  - 타임아웃 발생 시, 윈도우 내 모든 미확인 패킷 재전송
  - ACK 수신 시 base 갱신, 윈도우 이동, 타이머 관리

- **GBN 동작 예시:**
  - 여러 패킷을 연속 전송, 일부 패킷 손실 시 해당 패킷 이후 모든 패킷 재전송
  - 수신자는 순서가 맞지 않는 패킷은 버리고, 마지막으로 올바른 패킷에 대한 ACK만 반복 전송

Go-Back-N (GBN) 프로토콜 작동 방식

송신자는 한 번에 여러 개의 패킷을 보낼 수 있음
예를 들어, 윈도우 크기가 4라면 0번, 1번, 2번, 3번까지 한꺼번에 보냄

수신자는 순서대로 오는 패킷만 받음
0번 패킷을 받으면 ACK 0을 보냄
1번이 오면 ACK 1을 보냄
2번이 오면 ACK 2를 보냄
하지만 순서가 맞지 않으면 무시함

송신자는 패킷을 보낸 후 ACK를 기다림
0번, 1번에 대한 ACK가 오면 확인하고 윈도우를 앞당김
2번에 대한 ACK가 오지 않으면 대기함

2번 패킷이 손실되었다고 가정함
수신자는 3번 패킷이 와도 버리고
계속해서 ACK 1만 반복해서 보냄

송신자는 일정 시간이 지나도 2번에 대한 ACK가 오지 않으면 타임아웃 발생함
그러면 2번부터 3번까지, 아직 확인받지 못한 모든 패킷을 다시 보냄

수신자가 2번 패킷을 다시 받고 나면 ACK 2를 보냄
3번도 순서대로 오면 ACK 3을 보냄

송신자는 ACK를 받으면서 윈도우를 이동시키고
다음 순번의 패킷을 또 전송함

이런 식으로 순서대로 전송하고, 순서대로 확인받고
중간에 하나라도 빠지면 그 뒤는 다시 보냄

---

## Selective Repeat (SR) 프로토콜

- **수신자(Receiver):**
  - 올바르게 수신한 각 패킷에 대해 개별적으로 ACK 전송
  - 순서가 맞지 않는 패킷도 버퍼에 저장, 나중에 순서 맞게 상위 계층에 전달

- **송신자(Sender):**
  - ACK를 받지 못한 패킷만 개별적으로 재전송
  - 각 미확인 패킷마다 별도의 타이머 사용
  - 윈도우 크기 N: 연속된 N개의 순서 번호만큼 전송 가능

- **특징:**
  - Go-Back-N과 달리, 중간에 손실된 패킷만 재전송하여 효율성 증가
  - 송신자와 수신자 모두 버퍼링 필요

---

## Selective Repeat: 송신자/수신자 윈도우 구조 및 동작

### 송신자(Sender) 윈도우
- **send_base**: 현재 윈도우의 시작 시퀀스 번호
- **nextseqnum**: 다음에 전송할 시퀀스 번호
- **윈도우 크기 N**: 최대 N개의 미확인(ACK되지 않은) 패킷을 동시에 전송 가능
- 윈도우 내 상태:
  - 이미 ACK 받은 구간
  - 전송했으나 아직 ACK를 받지 못한 구간
  - 아직 전송하지 않은 구간
  - 윈도우 밖(전송 불가)

### 수신자(Receiver) 윈도우
- **rcv_base**: 수신자가 기대하는(다음에 올 것으로 예상하는) 시퀀스 번호
- **윈도우 크기 N**: 허용 가능한 시퀀스 번호 범위
- 윈도우 내 상태:
  - 이미 ACK한 패킷(버퍼에 있을 수 있음)
  - 아직 도착하지 않은, 기대 중인 패킷
  - 윈도우 밖(수용 불가)

### 동작 예시
- 송신자는 윈도우 내 여러 패킷을 연속 전송
- 수신자는 순서에 상관없이 올바른 패킷을 받으면 개별적으로 ACK 전송 및 버퍼링
- 순서가 맞는 패킷이 도착하면 상위 계층에 순서대로 전달
- 손실된 패킷만 재전송(타임아웃 발생 시)
- 중복 패킷이 도착할 수 있으므로, 수신자는 중복 데이터 전달을 방지해야 함

### 시퀀스 번호와 윈도우 크기의 관계
- 시퀀스 번호 공간이 너무 작으면, 중복 데이터가 상위 계층에 잘못 전달될 수 있음
- **안전한 관계:** 시퀀스 번호 공간 크기 ≥ 2 × 윈도우 크기(N)
  - 예: 윈도우 크기가 3이면, 시퀀스 번호는 최소 6개 필요(0~5)
- 이를 통해 중복 데이터가 새로운 데이터로 오인되는 문제를 방지

---
