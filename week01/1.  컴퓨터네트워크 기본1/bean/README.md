# 컴퓨터 네트워크 기본 정리

---

## 네트워크 구조

네트워크는 **노드간의 연결**로 계속 팽창한다. 우리(단말 노드)는 네트워크 **최외각**에 위치한다. 웹 서버도 마찬가지로 최외각에 위치하며, 전원을 끄면 바로 네트워크에서 사라진다. **중심에는 라우터들이 존재**한다.

### 라우터
네트워크의 중심에서 여러 네트워크를 연결하고, 데이터가 목적지까지 갈 수 있도록 경로를 결정하는 장치다. **인터넷의 교차로 역할**을 하며, 패킷이 올바른 목적지로 전달되도록 라우팅 테이블을 참조해 경로를 결정한다.

### 인터넷의 구성 요소
- **네트워크 엣지(가장자리)**: 데스크탑(사용자), 서버
- **네트워크 코어(중심)**: 라우터 간의 연결

### 클라이언트-서버
- **클라이언트**: 자기가 원할 때 링크에 연결해서 서버로 무언가를 받는 것
- **서버**: 상시 연결되어있어 클라이언트의 요청을 처리하는 것

---

## 인터넷에서 제공하는 통신 데이터 서비스

### Connection-Oriented Service
**TCP Service**가 해당된다.

**TCP의 간단한 3가지 특성**:
- 신뢰 가능한, 순서가 정렬된 데이터 전송
- 흐름 제어(속도가 오버되지 않게)
- 혼잡성 제어(네트워크 상황에 따라 조정)

### Connectionless Service
**User Datagram Protocol(UDP)**가 해당된다.
아무것도 안해준다. 그저 보내기만 할 뿐이다.

### UDP 사용 이유와 등장 배경
- **UDP**: 빠른 전송이 중요한 서비스에 사용된다. Discord, Youtube 등에서 사용한다.
- **TCP**: 신뢰성이 중요한 서비스에 사용된다. Web Page, Email 등에서 사용한다.

---

## 패킷과 자원

### 패킷
패킷은 **편지 봉투처럼 데이터가 담겨있는 부분**이다.
네트워크간 데이터 전송의 단위

### 컴퓨팅 자원과 네트워크 자원의 차이
- **컴퓨팅 자원**: CPU, 메모리, 저장장치 등 컴퓨터 내부의 자원
- **네트워크 자원**: 대역폭, 라우터, 링크 등 네트워크를 구성하는 자원

### 프로토콜
TCP, UDP 모두 **Protocol의 일종**이다. 어떻게 보낼지에 대한 규약이다. Python에서 `print("Hello")`를 함으로써 Hello를 출력하는 것과 비슷한 맥락이라 생각한다. Python으로 컴파일 하는데 `system.out.println("Hello");`를 한다면 에러가 날 것이다.

---

## TCP 연결 방식

**SYN**은 Synchronized, **ACK**는 Acknowledeged이다.
의역하면 연결, 인정?

### HTTP에서의 TCP 연결

#### 1단계 TCP 연결 설정 (3-way-handshake)
```
클라이언트 -> 서버 : SYN
서버 -> 클라이언트 : SYN + ACK
클라이언트 -> 서버 : ACK
```

#### 2단계 HTTP 요청 및 응답
```
클라이언트 -> 서버 : GET /index.html HTTP/1.1
서버 -> 클라이언트 : HTTP/1.1 200 OK + file Info
```

#### 3단계 TCP 연결 종료 (4-way-handshake)
```
클라이언트 -> 서버 : FIN
서버 -> 클라이언트 : ACK
서버 -> 클라이언트 : FIN
클라이언트 -> 서버 : ACK
```

### HTTPS에서의 TCP 연결

#### 1단계 TCP 연결 설정 (3-way-handshake)
```
클라이언트 -> 서버 : SYN
서버 -> 클라이언트 : SYN + ACK
클라이언트 -> 서버 : ACK
```

#### 2단계 SSL/TLS 핸드셰이크
```
클라이언트 -> 서버 : Client Hello (지원하는 암호화 방식)
서버 -> 클라이언트 : Server Hello (선택한 암호화 방식)
서버 -> 클라이언트 : Certificate (인증서)
서버 -> 클라이언트 : Server Key Exchange
클라이언트 -> 서버 : Client Key Exchange
클라이언트 -> 서버 : Finished
서버 -> 클라이언트 : Finished
```

#### 3단계: 암호화된 HTTP 통신
```
클라이언트 -> 서버 : [암호화된] GET /index.html HTTP/1.1
서버 -> 클라이언트 : [암호화된] HTTP/1.1 200 OK + 파일 내용
```

#### 4단계 TCP 연결 종료 (4-way-handshake)
```
클라이언트 -> 서버 : FIN
서버 -> 클라이언트 : ACK
서버 -> 클라이언트 : FIN
클라이언트 -> 서버 : ACK
```

**이와 같은 차이점이 존재**

---

## The Network Core

네트워크 코어는 **상호 연결된 라우터들의 망**(mesh of interconnected routers)으로 구성된다. 핵심 질문은 **"데이터가 네트워크를 통해 어떻게 전송되는가?"**이다.

### 데이터 전송 방식
- **Circuit Switching**: 전화망처럼 전용 회로를 사용한다. 통화마다 전용 회로가 할당된다.
- **Packet Switching**: 데이터를 개별 "청크"로 나누어 네트워크를 통해 전송한다.

### Circuit Switching의 특징
- End-to-end 자원이 "통화"를 위해 예약된다. 링크 대역폭, 스위치 용량이 전용으로 할당된다.
- **전용 자원**: 공유하지 않음
- **회로와 같은(보장된) 성능**
- **통화 설정이 필요하다**

### Packet Switching: Statistical Multiplexing
여러 사용자가 네트워크를 **공유**하여 사용한다. A와 B의 패킷 순서가 고정되지 않고, 필요에 따라 공유된다.

### Packet switching versus circuit switching
**Packet switching**은 더 많은 사용자가 네트워크를 사용할 수 있게 한다. **Circuit switching**은 전용 회로를 사용하므로 제한된 사용자만 사용 가능하다.

---

## 패킷 지연의 4가지 원인

1. **Nodal processing**: 비트 오류 확인, 출력 링크 결정
2. **Queueing**: 출력 링크에서 전송 대기 시간 (라우터 혼잡도에 따라 달라짐)
3. **Transmission delay**: 링크로 비트를 전송하는 시간 = L/R (L=패킷 길이, R=링크 대역폭)
4. **Propagation delay**: 물리적 링크를 통한 전파 시간 = d/s (d=링크 길이, s=전파 속도)

---

## 신뢰성 있는 데이터 전송(Principles of Reliable Data Transfer)

### 신뢰성 없는 채널에서 발생할 수 있는 문제
- **패킷 오류(Packet error)**: 데이터가 손상되어 도착
- **패킷 손실(Packet loss)**: 데이터가 아예 도착하지 않음

### 패킷 오류를 처리하는 메커니즘
- **오류 검출(Error detection)**: 데이터가 손상되었는지 확인 (예: 체크섬)
- **피드백(Feedback)**: 수신자가 송신자에게 정상 수신(ACK) 또는 오류(NAK)를 알림
- **재전송(Retransmission)**: 오류나 손실이 발생한 경우, 송신자가 데이터를 다시 전송
- **순서 번호(Sequence#)**: 패킷의 순서를 구분하여 중복/순서 오류 방지

### 패킷 손실을 처리하는 메커니즘
- **타임아웃(Timeout)**: 일정 시간 내에 응답이 없으면 송신자가 재전송

### 실제 프로토콜과의 관계
- 실제 프로토콜(TCP 등)은 더 복잡하지만, 위 원칙을 기반으로 동작함

---

## rdt3.0의 성능(Performance of rdt3.0)

- rdt3.0(Stop-and-Wait 방식)은 동작은 하지만 성능이 매우 낮음
- 예시: 1Gbps 링크, 15ms 왕복 지연, 1KB 패킷
  - 패킷 전송 시간(L/R): 8kb/1Gbps = 8마이크로초
  - 송신자 활용도(U): U = L/R / (RTT + L/R) ≈ 0.00027 (0.027%)
  - 1KB 패킷을 30ms마다 전송 → 초당 33kB 처리량 (1Gbps 링크에서 매우 비효율적)
- 네트워크 프로토콜이 물리적 자원 활용을 제한함

---

## 파이프라이닝 프로토콜(Pipelined Protocols)

- **파이프라이닝(Pipelining)**: 송신자가 여러 개의 패킷을 동시에 전송(아직 ACK를 받지 않은 상태)
  - 순서 번호 범위 증가 필요
  - 송신자/수신자 버퍼링 필요
- **Stop-and-Wait**: 한 번에 하나의 패킷만 전송, ACK를 받아야 다음 전송 가능
- **파이프라인 방식**: 여러 패킷을 연속적으로 전송 가능
- 파이프라인 프로토콜의 두 가지 대표 형태:
  - **Go-Back-N**
  - **Selective Repeat**

### 파이프라이닝의 효과
- 활용도(Throughput) 대폭 증가
- 예시: 3개의 패킷을 파이프라이닝하면 활용도가 3배 증가
  - U = 3*L/R / (RTT + L/R) ≈ 0.0008 (Stop-and-Wait 대비 3배)

---

